---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# portopt

Tools for simple portfolio optimization:

* Minimum variance portfolio for a given expected return, with no limits on allocations for individual asset classes other than that they must sum to 1. (That is, shorting and leverage are allowed.)

* Minimum variance portfolio with lower and upper bounds on allocations for asset classes. It can also accommodate more-general linear constraints on asset classes. (For example, stocks plus bonds combined must be between 40% and 60% of the portfolio.)

* Efficient frontier

`portopt` cannot handle nonlinear constraints on asset allocations, and it cannot find an optimal portfolio that satisfies more-complex objectives, such as value-at-risk criteria. For my purposes, so far, these are not necessary. `portopt` uses `solve.QP` from the package `quadprog` for minimum-variance optimization. Other solvers would be required for more-complex optimization.

I wrote `portopt` because I was looking for basic portfolio optimization tools in `R`. There are many available packages, but the package that looked like it would be most useful, `PortfolioAnalytics`, recently was removed from `CRAN` although I have installed it from github. It seems very powerfu. At some point I may use it, or `fPortfolio`, instead of this.

## portopt data sets

`portopt` includes several data sets, each with expected returns, standard deviations, and a correlation matrix for multiple asset classes. These data sets are used in the examples below. Each data set is a list with two elements:

* `ersd` - a data frame with columns class (the asset class), er (expected return), and sd (standard deviation)
* `cormat` - a correlation matrix for these assets. Thus, the number of rows and number of columns equal the number of asset classes. The row names and column names are the asset-class names.

The data sets and their respective sources are:

* `stalebrink` -- Stalebrink, O. J. “Public Pension Funds and Assumed Rates of Return: An Empirical Examination of Public Sector Defined Benefit Pension Plans.” The American Review of Public Administration 44, no. 1 (January 1, 2014): 92–111. https://doi.org/10.1177/0275074012458826.

* `rvk` -- RVK. “Asset/Liability Study: Los Angeles Fire and Police Pension System.” RVK, Inc., October 2015.

* `horizon10year2017` -- “Survey of Capital Market Assumptions: 2017 Edition.” Horizon Actuarial Services, LLC, August 2017. http://www.horizonactuarial.com/uploads/3/0/4/9/30499196/horizon_cma_survey_2017_v0822.pdf.

The associated documents are in the "docs" folder of this project, on the github site

The examples below use these datasets.


## Installation

Install as follows:

``` r
devtools::install_github("donboyd5/portopt")
```

## Examples

### Get basic information about a dataset

```{r basic, warning=FALSE, message=FALSE}
library("portopt")
library("magrittr")
library("Matrix")
library("quadprog")
library("tidyverse")

stalebrink
aa.wts <- c(.25, .25, .1, .15, .1, .05) # asset-allocation weights
per(stalebrink$ersd$er, aa.wts) # portfolio expected return with these weights
psd(stalebrink$cormat, stalebrink$ersd$sd, aa.wts) # portfolio standard deviation with these weights

```


### Get the minimum variance portfolio for a given expected return

```{r portfolios}
# Create several minimum-variance portfolios

# no restrictions on asset allocation - shorting and leverage allowed
minvport(.09, stalebrink$ersd, stalebrink$cormat)$portfolio

# shorting and leverage NOT allowed:
minvport(.09, stalebrink$ersd, stalebrink$cormat, 0, 1)$portfolio

# shorting and leverage NOT allowed, 40% upper bound on real estate:
minvport(.09, stalebrink$ersd, stalebrink$cormat, 0, c(1, 1, 1, .4, 1, 1))$portfolio

```


### Check whether correlation matrix is positive definite
While it can be fixed, the differences between the original and adjusted correlation matrices can be large.
This requires investigation.
```{r check}
is.PD(stalebrink$cormat) # good

is.PD(rvk$cormat) # bad
cormat2 <- makePDcorr(rvk$cormat)
is.PD(cormat2)
# compare:
rvk$cormat %>% round(., 2)
cormat2 %>% round(., 2)
(cormat2 - rvk$cormat) %>% round(., 2)

```




### Get and graph the efficient frontier

```{r efrontier, echo = FALSE}
ef.nobound <- efrontier(seq(.00, .20, .0025), stalebrink$ersd, stalebrink$cormat)
ef.noshort <- efrontier(seq(.00, .20, .0025), stalebrink$ersd, stalebrink$cormat, 0, 1)

# create a data frame with just the data we want
efdf <- bind_rows(ef.nobound$efrontier %>% mutate(rule="no bounds on allocation"),
                  ef.noshort$efrontier %>% mutate(rule="no shorts or leverage")) %>%
  filter(type=="high", !is.na(per))

ggplot() +
  geom_line(data=efdf, aes(psd, per, colour=rule)) +
  scale_x_continuous(name="Standard deviation", breaks=seq(0, .3, .025), labels = scales::percent) +
  scale_y_continuous(name="Expected return", breaks=seq(0, .2, .01), labels = scales::percent) +
  ggtitle("Efficient frontier for the Stalebrink capital market assumptions", subtitle="With and without bounds on asset allocations") +
  # now add the asset-class points
  geom_point(data=ef.nobound$ersd, aes(x=sd, y=er)) +
  geom_text(data=ef.nobound$ersd, aes(x=sd, y=er, label=class), nudge_y = +.003)
```


